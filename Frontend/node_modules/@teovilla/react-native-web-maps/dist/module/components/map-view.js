import { GoogleMap, useJsApiLoader } from '@react-google-maps/api';
import React, { forwardRef, memo, useCallback, useEffect, useImperativeHandle, useMemo, useState } from 'react';
import { mapMouseEventToMapEvent } from '../utils/mouse-event';
import { transformRNCameraObject } from '../utils/camera';
import { logMethodNotImplementedWarning, logDeprecationWarning } from '../utils/log';
import { useUserLocation } from '../hooks/use-user-location';
import { UserLocationMarker } from './user-location-marker';
import * as Location from 'expo-location';
function _MapView(props, ref) {
  // State

  const [map, setMap] = useState(null);
  const [isGesture, setIsGesture] = useState(false);
  const userLocation = useUserLocation({
    showUserLocation: props.showsUserLocation || false,
    requestPermission: props.showsUserLocation || !!props.onUserLocationChange || false,
    onUserLocationChange: props.onUserLocationChange,
    followUserLocation: props.followsUserLocation || false
  });
  const {
    isLoaded
  } = useJsApiLoader({
    googleMapsApiKey: props.googleMapsApiKey || ''
  });

  // Callbacks

  const _onMapReady = useCallback(_map => {
    var _props$onMapReady;
    setMap(_map);
    (_props$onMapReady = props.onMapReady) === null || _props$onMapReady === void 0 ? void 0 : _props$onMapReady.call(props);
  }, [map, props.onMapReady]);
  const _onDragStart = useCallback(() => {
    setIsGesture(true);
  }, []);
  const _onRegionChange = useCallback(() => {
    const bounds = map === null || map === void 0 ? void 0 : map.getBounds();
    if (bounds) {
      var _props$onRegionChange;
      const northEast = bounds.getNorthEast();
      const southWest = bounds.getSouthWest();
      const longitudeDelta = Math.abs(northEast.lng() - southWest.lng());
      const latitudeDelta = Math.abs(northEast.lat() - southWest.lat());
      const center = bounds.getCenter();
      (_props$onRegionChange = props.onRegionChange) === null || _props$onRegionChange === void 0 ? void 0 : _props$onRegionChange.call(props, {
        latitude: center.lat(),
        longitude: center.lng(),
        latitudeDelta,
        longitudeDelta
      }, {
        isGesture
      });
    }
  }, [map, props.onRegionChange, isGesture]);
  const _onRegionChangeComplete = useCallback(() => {
    const bounds = map === null || map === void 0 ? void 0 : map.getBounds();
    if (bounds) {
      var _props$onRegionChange2;
      const northEast = bounds.getNorthEast();
      const southWest = bounds.getSouthWest();
      const longitudeDelta = Math.abs(northEast.lng() - southWest.lng());
      const latitudeDelta = Math.abs(northEast.lat() - southWest.lat());
      const center = bounds.getCenter();
      (_props$onRegionChange2 = props.onRegionChangeComplete) === null || _props$onRegionChange2 === void 0 ? void 0 : _props$onRegionChange2.call(props, {
        latitude: center.lat(),
        longitude: center.lng(),
        latitudeDelta,
        longitudeDelta
      }, {
        isGesture
      });
    }
    setIsGesture(false);
  }, [map, props.onRegionChange, isGesture]);

  // Ref handle

  useImperativeHandle(ref, () => ({
    async getCamera() {
      const center = map === null || map === void 0 ? void 0 : map.getCenter();
      return {
        altitude: 0,
        heading: (map === null || map === void 0 ? void 0 : map.getHeading()) || 0,
        pitch: (map === null || map === void 0 ? void 0 : map.getTilt()) || 0,
        // TODO: Review this
        zoom: (map === null || map === void 0 ? void 0 : map.getZoom()) || 0,
        // TODO: Normalize value
        center: {
          latitude: (center === null || center === void 0 ? void 0 : center.lat()) || 0,
          longitude: (center === null || center === void 0 ? void 0 : center.lng()) || 0
        }
      };
    },
    setCamera(camera) {
      map === null || map === void 0 ? void 0 : map.moveCamera(transformRNCameraObject(camera));
    },
    animateCamera(camera, _opts) {
      map === null || map === void 0 ? void 0 : map.moveCamera(transformRNCameraObject(camera));
    },
    async getMapBoundaries() {
      const bounds = map === null || map === void 0 ? void 0 : map.getBounds();
      const northEast = bounds === null || bounds === void 0 ? void 0 : bounds.getNorthEast();
      const southWest = bounds === null || bounds === void 0 ? void 0 : bounds.getSouthWest();
      return {
        northEast: {
          latitude: (northEast === null || northEast === void 0 ? void 0 : northEast.lat()) || 0,
          longitude: (northEast === null || northEast === void 0 ? void 0 : northEast.lng()) || 0
        },
        southWest: {
          latitude: (southWest === null || southWest === void 0 ? void 0 : southWest.lat()) || 0,
          longitude: (southWest === null || southWest === void 0 ? void 0 : southWest.lng()) || 0
        }
      };
    },
    animateToRegion(region, _duration) {
      const bounds = new google.maps.LatLngBounds();

      // Source: https://github.com/react-native-maps/react-native-maps/blob/master/android/src/main/java/com/airbnb/android/react/maps/AirMapView.java#L503

      // southWest
      bounds.extend({
        lat: region.latitude - region.latitudeDelta / 2,
        lng: region.longitude - region.longitudeDelta / 2
      });

      // northEast
      bounds.extend({
        lat: region.latitude + region.latitudeDelta / 2,
        lng: region.longitude + region.longitudeDelta / 2
      });

      // panToBounds not working??
      // map?.panToBounds(bounds);
      map === null || map === void 0 ? void 0 : map.fitBounds(bounds);
    },
    fitToCoordinates(coordinates, options) {
      const bounds = new google.maps.LatLngBounds();
      if (coordinates) {
        coordinates === null || coordinates === void 0 ? void 0 : coordinates.forEach(c => bounds.extend({
          lat: c.latitude,
          lng: c.longitude
        }));
      }
      map === null || map === void 0 ? void 0 : map.fitBounds(bounds, options === null || options === void 0 ? void 0 : options.edgePadding);
    },
    setMapBoundaries(northEast, southWest) {
      const bounds = new google.maps.LatLngBounds();
      bounds.extend({
        lat: northEast.latitude,
        lng: northEast.longitude
      });
      bounds.extend({
        lat: southWest.latitude,
        lng: southWest.longitude
      });
      map === null || map === void 0 ? void 0 : map.fitBounds(bounds);
    },
    async pointForCoordinate(coordinate) {
      var _map$getProjection;
      const point = map === null || map === void 0 || (_map$getProjection = map.getProjection()) === null || _map$getProjection === void 0 ? void 0 : _map$getProjection.fromLatLngToPoint({
        lat: coordinate.latitude,
        lng: coordinate.longitude
      });
      return point || {
        x: 0,
        y: 0
      };
    },
    async coordinateForPoint(point) {
      var _map$getProjection2;
      const coord = map === null || map === void 0 || (_map$getProjection2 = map.getProjection()) === null || _map$getProjection2 === void 0 ? void 0 : _map$getProjection2.fromPointToLatLng(new google.maps.Point(point.x, point.y));
      return {
        latitude: (coord === null || coord === void 0 ? void 0 : coord.lat()) || 0,
        longitude: (coord === null || coord === void 0 ? void 0 : coord.lng()) || 0
      };
    },
    async takeSnapshot(_options) {
      logMethodNotImplementedWarning('takeSnapshot');
      return '';
    },
    async addressForCoordinate(_coordinate) {
      Location.setGoogleApiKey(props.googleMapsApiKey || '');
      const [address] = await Location.reverseGeocodeAsync(_coordinate, {
        useGoogleMaps: true
      });
      return address ? {
        administrativeArea: address.region || '',
        country: address.country || '',
        countryCode: address.isoCountryCode || '',
        locality: address.city || '',
        postalCode: address.postalCode || '',
        name: address.name || '',
        subAdministrativeArea: address.subregion || '',
        subLocality: address.city || '',
        thoroughfare: ''
      } : null;
    },
    animateToNavigation(_location, _bearing, _angle, _duration) {
      logDeprecationWarning('animateToNavigation');
    },
    animateToCoordinate(_latLng, _duration) {
      logDeprecationWarning('animateToCoordinate');
    },
    animateToBearing(_bearing, _duration) {
      logDeprecationWarning('animateToBearing');
    },
    animateToViewingAngle(_angle, _duration) {
      logDeprecationWarning('animateToViewingAngle');
    },
    fitToElements(_options) {
      logMethodNotImplementedWarning('fitToElements');
    },
    fitToSuppliedMarkers(_markers, _options) {
      logMethodNotImplementedWarning('fitToSuppliedMarkers');
    },
    setIndoorActiveLevelIndex(_index) {
      logMethodNotImplementedWarning('setIndoorActiveLevelIndex');
    }
  }), [map]);

  // Side effects

  useEffect(() => {
    if (props.followsUserLocation && userLocation) {
      map === null || map === void 0 ? void 0 : map.panTo({
        lat: userLocation.coords.latitude,
        lng: userLocation.coords.longitude
      });
    }
  }, [props.followsUserLocation, userLocation]);
  const mapNode = useMemo(() => {
    var _props$initialCamera, _props$initialCamera2, _props$initialCamera3, _props$initialCamera4, _props$initialRegion, _props$initialCamera5, _props$initialRegion2;
    return /*#__PURE__*/React.createElement(GoogleMap, {
      onLoad: _onMapReady,
      onBoundsChanged: _onRegionChange,
      onDragStart: _onDragStart,
      onDragEnd: _onRegionChangeComplete,
      mapContainerStyle: {
        flex: 1
      },
      zoom: ((_props$initialCamera = props.initialCamera) === null || _props$initialCamera === void 0 ? void 0 : _props$initialCamera.zoom) || 3,
      heading: (_props$initialCamera2 = props.initialCamera) === null || _props$initialCamera2 === void 0 ? void 0 : _props$initialCamera2.heading,
      tilt: (_props$initialCamera3 = props.initialCamera) === null || _props$initialCamera3 === void 0 ? void 0 : _props$initialCamera3.pitch,
      onDrag: () => {
        var _props$onPanDrag;
        const center = map === null || map === void 0 ? void 0 : map.getCenter();
        (_props$onPanDrag = props.onPanDrag) === null || _props$onPanDrag === void 0 ? void 0 : _props$onPanDrag.call(props, mapMouseEventToMapEvent(null, center && {
          latitude: center.lat(),
          longitude: center.lng()
        }, map, undefined));
      },
      onClick: e => {
        var _props$onPress;
        return (_props$onPress = props.onPress) === null || _props$onPress === void 0 ? void 0 : _props$onPress.call(props, mapMouseEventToMapEvent(e, null, map, 'press'));
      },
      onDblClick: e => {
        var _props$onDoublePress;
        return (_props$onDoublePress = props.onDoublePress) === null || _props$onDoublePress === void 0 ? void 0 : _props$onDoublePress.call(props, mapMouseEventToMapEvent(e, null, map, 'press'));
      },
      center: map ? map.getCenter() : {
        lat: ((_props$initialCamera4 = props.initialCamera) === null || _props$initialCamera4 === void 0 ? void 0 : _props$initialCamera4.center.latitude) || ((_props$initialRegion = props.initialRegion) === null || _props$initialRegion === void 0 ? void 0 : _props$initialRegion.latitude) || 0,
        lng: ((_props$initialCamera5 = props.initialCamera) === null || _props$initialCamera5 === void 0 ? void 0 : _props$initialCamera5.center.longitude) || ((_props$initialRegion2 = props.initialRegion) === null || _props$initialRegion2 === void 0 ? void 0 : _props$initialRegion2.longitude) || 0
      },
      options: {
        scrollwheel: props.zoomEnabled,
        disableDoubleClickZoom: !props.zoomTapEnabled,
        zoomControl: props.zoomControlEnabled,
        rotateControl: props.rotateEnabled,
        minZoom: props.minZoomLevel,
        // TODO: Normalize value
        maxZoom: props.maxZoomLevel,
        // TODO: Normalize value
        scaleControl: props.showsScale,
        styles: props.customMapStyle,
        ...(props.options || {})
      }
    }, props.showsUserLocation && userLocation && /*#__PURE__*/React.createElement(UserLocationMarker, {
      coordinates: userLocation.coords
    }));
  }, [_onRegionChange, _onMapReady, userLocation, props.initialCamera, props.initialRegion, props.showsUserLocation, props.onPanDrag, props.onPress, props.onDoublePress, props.zoomEnabled, props.zoomTapEnabled, props.zoomControlEnabled, props.rotateEnabled, props.minZoomLevel, props.maxZoomLevel, props.showsScale, props.customMapStyle, props.options]);
  if (props.provider !== 'google') {
    console.warn('[WARNING] `react-native-web-maps` only suppots google for now. Please pass "google" as provider in props');
    return null;
  }
  return isLoaded ? /*#__PURE__*/React.cloneElement(mapNode, {
    children: props.children
  }) : /*#__PURE__*/React.createElement(React.Fragment, null, props.loadingFallback || null);
}
export const MapView = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(_MapView));
//# sourceMappingURL=map-view.js.map